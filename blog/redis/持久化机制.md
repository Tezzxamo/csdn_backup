<!-- TOC -->
* [概要](#概要)
* [持久化机制：](#持久化机制)
  * [一、RDB：内存快照持久化](#一rdb内存快照持久化)
  * [二、AOF：写命令日志持久化](#二aof写命令日志持久化)
  * [三、混合持久化（默认开启）：](#三混合持久化默认开启)
<!-- TOC -->

# 概要

    redis可以理解为是一个内存数据库，默认数据仅存于内存中，重启后会消失，所以redis提供了持久化机制，可以确保数据在重启后恢复。
    目前redis提供了三种持久化机制，RDB(快照)、AOF(日志追加)、混合策略持久化

---

# 持久化机制：

## 一、RDB：内存快照持久化

- 核心原理：定时生成内存数据的二进制快照文件，默认为`dump.rdb`，恢复时直接加载快照到内存中内存，速度极快
- 触发方式：
    - 手动触发：
        - save命令：阻塞线程，生成快照文件。
        - bgsave命令：异步触发，fork一个子进程负责生成快照文件。
    - 自动触发：<br/>
      通过配置文件控制，通过语句：`save m n`的格式进行配置，m为时间间隔，n为操作次数，满足条件时生成快照文件。<br/>
      如：
      ``` text
      save 900 1    # 900秒内有1次写操作，触发bgsave
      save 300 10   # 300秒内有10次写操作，触发bgsave
      save 60 10000 # 60秒内有10000次写操作，触发bgsave
      ```
    - 优点：快照体积小，恢复速度快，适合备份
    - 缺点：可能会丢失最后一次快照后的数据（如突发宕机）；fork()子进程时会占用额外内存；频繁触发会影响性能；

## 二、AOF：写命令日志持久化

- 核心原理：AOF记录所有写操作的命令追加到文件中，默认为`appendonly.aof`，恢复时通过重新执行AOF文件中的写指令，来达到恢复数据的目的。
- 同步策略：
    ``` text
      appendfsync always    # 每次写操作都追加，同步写回。
      appendfsync everysec  # 每秒追加一次，每秒写回。
      appendfsync no        # 由操作系统控制的写回
    ```
- AOF重写：通过重写删除无效命令，合并重复命令，减少AOF文件体积。
    - 手动触发：
        - 执行 bgrewriteaof 命令（异步，不阻塞主线程）。
    - 自动触发：通过配置 `auto-aof-rewrite-percentage` 和 `auto-aof-rewrite-min-size` 控制:
      ``` text
      auto-aof-rewrite-percentage 100  # AOF 文件比上次重写后增长100%时触发
      auto-aof-rewrite-min-size 64mb    # AOF 文件最小64MB才触发重写
      ```
- 优点：数据完整性高；日志可读性强，可手动修复错误命令；重写机制可压缩文件大小；
- 缺点：恢复速度慢，文件远大于rdb文件，重写时会占用CPU和内存资源。
- 关键配置：
    ``` text
    appendonly yes                   # 开启 AOF 持久化（默认 no）
    appendfilename "appendonly.aof"  # AOF 文件名
    appendfsync everysec             # 每秒同步一次（推荐）
    dir /var/lib/redis               # AOF 文件存储目录
    aof-use-rdb-preamble yes         # 开启混合持久化（Redis 4.0+，默认 yes）
    ```

---

## 三、混合持久化（默认开启）：

描述：
- 结合RDB与AOF的优点和特点的一种持久化方式。
- 使用混合持久化后，AOF文件重写后，文件头部是RDB的二进制快照，尾部是增量写命令日志。

恢复的流程为：`先加载RDB快照，再执行增量写命令。`