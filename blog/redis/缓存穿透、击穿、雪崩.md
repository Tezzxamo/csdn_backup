# 概要

客户端与缓存、数据库交互时的异常场景。

# 缓存穿透

- 核心概念：查询的数据在缓存、数据库中都不存在，导致所有请求直接穿透缓存进入到数据库中，造成数据库压力过载甚至宕机。
- 解决方案：
    - 1、参数校验：接口层过滤明显的无效参数，如用户id为负数。
    - 2、限流与熔断：对接口设置QPS阈值，限制单位时间内的请求次数；当数据库压力达到阈值时，触发熔断，返回默认数据或提示系统繁忙。
    - 3、缓存空值：对查询结果为空的数据，在redis缓存空值并设置过期时间。
    - 4、布隆过滤器：通过多个哈希函数将数据映射到二进制数组中，快速判断KEY是否存在，若不存在则拦截请求，数据新增时同步更新布隆过滤器。但是因为布隆过滤器不支持删除操作，所以需要定期重建，避免误判率提升。

# 缓存击穿

- 核心概念：某个热点数据KEY过期时(或热点KEY未预热)，大量请求直接进入到数据库中，导致数据库瞬间压力骤增。
- 解决方案：
    - 1、本地缓存兜底：在应用服务器本地缓存一份热点数据，当热点数据失效时，先从本地缓存中获取，为redis更新争取时间。
    - 2、热点KEY不过期：缓存KEY不设置过期时间，使用逻辑过期，访问时若逻辑过期，则异步更新缓存并返回旧数据。
    - 3、互斥锁(分布式锁)：缓存失效时，仅允许一个请求线程查询数据库并更新缓存，其他请求线程等待或重试。
    - 4、熔断降级：缓存失效时，若数据库压力过大，直接返回默认值或提示系统繁忙，保护数据库。(结合Sentinel 或 Hystrix)

# 缓存雪崩

- 核心概念：击穿的升级版，短时间内多个缓存KEY失效，大量请求直接进入数据库中，引发连锁反应甚至系统崩溃。
- 解决方案：
    - 1、分散过期时间：在基础过期时间上叠加随机值，避免击中失效，如TTL = 3600 + Random(0,300)
    - 2、高可用：采用集群/主从+哨兵，避免单节点故障导致缓存不可用。
    - 3、缓存预热：提前将热点KEY加载到缓存中，而不是等用户请求。
    - 4、互斥锁(分布式锁)：缓存失效时，仅允许一个请求线程查询数据库并更新缓存，其他请求线程等待或重试。
    - 5、多级缓存：当redis缓存失效时，从本地缓存中请求，避免直接冲击数据库。
    - 6、限流与熔断：对接口设置QPS阈值，限制单位时间内的请求次数；当数据库压力达到阈值时，触发熔断，返回默认数据或提示系统繁忙。