# 概要

索引是存储在数据库中的数据结构，索引允许数据库查询数据，而不需要扫描整个表。索引的创建和删除，以及索引的优化，都是数据库管理员需要完成的工作。
索引的种类有许多种，常见的有：

- 按照数据结构分类：
    - B-Tree索引
    - B+树索引
    - 哈希索引
    - 全文索引
    - R树索引
    - 位图索引
    - 列存储索引
- 按功能用途分类：
    - 主键索引
    - 唯一索引
    - 普通索引
    - 联合索引
- 按存储位置分类：
    - 聚集索引
    - 非聚集索引

# 一、按照数据结构分类：

## 1、B-Tree索引：

- 核心特征：所有节点都存储数据，叶子结点无链表连接，叶子结点都在同一层。
- 图例网站：https://www.cs.usfca.edu/~galles/visualization/BTree.html
- 单值查询：可能在非叶子结点命中数据，直接返回，也可能查询到叶子结点命中数据，查询效率不稳定。
- 范围查询：需要从根节点逐层定位，可能多次回溯父节点，效率低。
- 排序与全表扫描：需中序遍历所有节点，包含非叶子结点的冗余访问，效率低。
- 节点大小：每个节点存储键值、数据、指针，空间利用率较低，相同数据量下，比B+树更高，导致需要更多的磁盘IO。

## 2、B+树索引：

- 核心特征：只有叶子结点存储数据，且叶子结点通过链表连接，非叶子结点只存储键值和子节点指针。
- 图例网站：https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html
- 单值查询：必须遍历到叶子结点才能命中数据，但因为树高更低，键值更密集，整体IO反而更少，效率更高，查询效率稳定。
- 范围查询：通过叶子结点可以直接顺序遍历，效率极高。
- 排序与全表扫描：叶子结点天然有序，`order by`操作可以直接利用链表排序，全表扫描只需遍历链表。
- 节点大小：非叶子节点只存储键值和指针，空间利用率极高。
- 磁盘预读：顺序访问叶子结点链表时，磁盘预读机制可提前加载相邻数据页，进一步提升性能。
- 使用场景：`InnoDB`引擎默认使用B+树索引。

## 3、哈希索引：

- 通过哈希函数计算索引键的槽位，槽位中存储索引键和指向数据行的指针。例如user_id =
  123，通过哈希函数计算出槽位后，直接定位数据行，时间复杂度为O(1)。
- InnoDB：自适应哈希索引，由引擎自动为高频使用的索引键创建哈希索引，提升查询速度，但用户无法手动控制。
- 优点：效率高、等值查询极快。
- 缺点：不支持范围查询；无法排序与分组；冲突性能损耗（数据分布不均时，链表过长会降低查询效率）。

## 4、全文索引：

- 全文索引通过倒排索引实现，将文本拆分为单词，记录单词到文档的映射关系。
- 例如：文本“我爱编程”，被分词为“我”、“爱”、“编程”，倒排表存储每个单词对应的文档ID和位置。
- 自然语言模式：结果按照相关性评分降序排序，过滤“高频词”（若高频词出现在超过50%的记录中直接忽略），忽略停用词。
- 布尔模式：支持逻辑运算的精准检索模式，无相关性评分，按照数据物理顺序返回。
- 查询扩展模式：先按照初始词检索，得到一批结果，再从这批结果中提取高频词，再通过初始词+扩展词重新检索。
- 基本语法：
    ```sql
    CREATE TABLE articles (
        id INT AUTO_INCREMENT PRIMARY KEY,
        title VARCHAR(255),
        content TEXT
    );
    -- 清空原有数据，插入中文测试数据
    TRUNCATE articles;
    INSERT INTO articles (title, content) VALUES
    (1, 'MySQL优化指南', '本指南介绍如何通过索引和查询优化MySQL性能'),
    (2, 'Python编程教程', '学习Python基础和数据分析进阶技巧'),
    (3, 'MySQL索引最佳实践', 'B+树索引和全文索引是MySQL优化的关键'),
    (4, '数据库性能调优', '优化数据库性能，包括MySQL、PostgreSQL和Oracle');
    
    -- 创建中文全文索引（指定ngram分词器）
    DROP INDEX idx_ft_title_content ON articles;
    CREATE FULLTEXT INDEX idx_ft_title_content ON articles(title, content) WITH PARSER ngram;
    -- 查询(默认采用NATURAL LANGUAGE MODE)
    # 查询结果返回id为1/3/4的数据，因为MySQL优化被拆分为MySQL、优化，只要title/content包含就会被匹配
    # id=1:title、content包含MySQL优化，同时匹配，评分最高
    # id=3:title包含MySQL，content包含MySQL优化，评分次之
    # id=4:content包含MySQL+优化，但是无title匹配，评分最低
    # id=2:无匹配分词，过滤。
    select * from articles where match(title, content) against('MySQL优化');
    -- 布尔模式(BOOLEAN MODE)，
    # 精准匹配，仅id=3匹配
    select * from articles where match(title) against('MySQL索引' IN BOOLEAN MODE);
    # 必须有MySQL，没有Oracle，还得匹配有优化这个前缀的词，id=1，id=3匹配
    select * from articles where match(title) against('+MySQL - Oracle 优化*' IN BOOLEAN MODE);
    -- 查询扩展模式：初始检索、扩展检索、最终检索
    # 普通查询扩展：WITH QUERY EXPANSION，检索“MySQL优化”，并扩展相关词（如索引、性能）
    SELECT * FROM articles WHERE MATCH(title, content) AGAINST('MySQL优化' WITH QUERY EXPANSION);
    # 布尔查询扩展（WITH BOOLEAN QUERY EXPANSION），必须包含MySQL，排除Oracle，并扩展相关词
    SELECT * FROM articles WHERE MATCH(title, content) AGAINST('+MySQL -Oracle' WITH BOOLEAN QUERY EXPANSION);
    ```

# 二、按功能用途分类：

## 1、主键索引：

- 主键唯一且不能为null，表的核心标识。
- MySQL的InnoDB会为主键自动创建聚集索引，数据行按照主键值顺序物理存储在磁盘上。
- 一张表只能有一个主键索引。

## 2、唯一索引：

- 唯一索引：确保索引值唯一，但是允许有一个null值。
- 典型场景：手机号、身份证。

## 3、普通索引：

- 普通索引：无约束的基础索引。
- 典型场景：姓名、文章标题、商品名称。
- 注意事项：需要回表查询完整数据，避免使用低选择性的字段创建普通索引，如性别、状态。

## 4、联合索引：

- 联合索引：多字段组合索引，服从最左匹配原则。
- 最左匹配原则：查询条件需要从索引的最左侧字段开始连续匹配，否则索引可能失效。
    - 如索引(a,b,c)：
  ```sql
  # 索引生效场景：
  WHERE a=?;
  WHERE a=? AND b=?;
  WHERE a=? AND b=? AND c=?;
  # 索引失效场景：
  WHERE b=?;               -- 跳过a
  WHERE a=? AND c=?;        -- 跳过b
  ```
- 优化建议：有限将高选择性字段放在最左侧，将等值查询字段放在左侧，范围查询字段放在右侧。

# 三、按存储位置分类：

## 1、聚集索引：

- 聚集索引：索引即数据，数据即索引，叶子结点存储完整的数据行，数据按主键值顺序存储在磁盘上。
- 唯一性：一张表只能有一个聚集索引。
- 主键索引就是聚集索引。

## 2、非聚集索引：

- 非聚簇索引：索引与数据分离，靠指针关联，叶子结点只存储索引键值和指向数据行的指针（在`innodb`中为主键值，在`MyIASM`中为物理地址）。
- 普通索引和唯一索引都是非聚集索引。
- 灵活性：一张表可以建立多个非聚集索引，支持多字段查询优化。
- 有可能需要回表，如：`select * from users where name = '张三'`，需要通过给`name`建立的索引先找到主键值，再通过主键索引（聚集索引）找到数据行获得完整数据。
- 覆盖索引优化，如：`select id,name from users where name = '张三'`，若查询字段包含在索引中，则可避免回表，性能接近聚集索引。
