# MySQL：

| 考察方向     | 核心知识点              |
|----------|--------------------|
| 架构与存储引擎  | 体系结构、InnoDB与MyISAM |
| 索引       | B+树、索引类型、最左前缀、索引失效 |
| 事务与锁     | ACID、隔离级别、MVCC、锁类型 |
| SQL优化与调优 | EXPLAIN、慢查询、优化策略   |
| 高可用      | 主从复制、分库分表          |

# Redis:

| 考察方向    | 核心知识点                                   | 简要说明                                                                                                                   |
|---------|-----------------------------------------|------------------------------------------------------------------------------------------------------------------------|
| 基础特性    | 核心特点、适用场景、与MySQL区别                      | 内存数据库（读写快）、单线程（避免锁竞争）、支持多种数据结构；使用于缓存/计数器/分布式锁等，补MySQL高并发短板                                                             |
| 核心数据结构  | 八种数据结构                                  | String:二进制安全；Hash:适合存储对象；List:双向链表，支持栈/队列；Set:无序去重，支持交集并集；ZSet:跳表实现，按分数排序；BitMap:位运算，适用于签到；HyperLogLog:基数统计；Geo：地理位置计算 |
| 持久化机制   | RDB/AOF/混合持久化                           | RDB:定时快照，恢复快但可能丢数据；AOF：日志追加，数据可靠但文件大；混合持久化：RDB+AOF，结合两者优势，默认开启                                                         |
| 高可用方案   | 主从复制、哨兵（sentinel)、Redis Cluster         | 主从：一主多从，主写从读；哨兵：监控主从，自动故障转移；Cluster：分片存储，3主3从默认，支持水平扩容                                                                 |
| 缓存常见问题  | 缓存穿透、缓存击穿、缓存雪崩、缓存一致性                    | 穿透：查不存在的KEY（布隆过滤器/空值缓存）；击穿：热点KEY过期（互斥锁/永不过期）；雪崩：大量KEY同时过期（过期时间随机化/集群部署）；一致性：最终一致性（延迟双删）、强一致性（加锁）                       |
| 分布式场景应用 | 分布式锁、分布式限流、共享Session                    | 分布式锁：set nx ex + Lua脚本；限流：基于ZSet/计数器+过期时间；共享session：缓存用户会话，实现分布式系统会话共享                                                 |
| 事务与原子性  | Redis事务（MULTI/EXEC/DISCARD/WATCH)、Lua脚本 | redis事务：不是严格ACID事务，核心是“批量命令串行执行”；lua脚本：实现原子性，支持复杂逻辑                                                                    |
| 内存优化与淘汰 | 内存淘汰策略、过期键删除机制                          | 淘汰策略：volatile-*,allkeys-*,noeviction（默认无操作）;过期键删除：惰性删除+定期删除+内存淘汰联动                                                     |
| 性能优化    | Pipeline、批量操作、数据结构选型、网络优化               | Pipeline：批量发送命令，减少网络往返；避免大KEY；合理选型数据结构                                                                                 |
| 其他关键考点  | 发布订阅、Redis6.0新特性、集群槽位分配（16384个）、持久化配置优化 | 发布订阅：支持消息广播；6.0新特性：多线程IO、ACL权限空值；槽位：集群通过槽位分片数据，每个节点负责部分槽位                                                              |

# rabbitMq:

| 考察方向      | 核心知识点                                                     | 简要说明                                                            |
|-----------|-----------------------------------------------------------|-----------------------------------------------------------------|
| 基础特性与核心概念 | 核心特点、消息模型（生产者→交换机→队列→消费者）、AMQP协议                          | 基于AMQP协议，解耦异步通信；核心模型（生产者→交换机→队列→消费者），路由逻辑由交换机实现                 |
| 核心组件      | 生产者、消费者；交换机、绑定、队列、Broker                                  | 生产者发消息，消费者收消息；交换机路由消息，队列存储消息；绑定定义交换机与队列的关联规则                    |
| 交换机类型     | 直连、主题、扇出、头                                                | 直连：精准匹配routingKey;主题：通配符匹配；扇出：广播（忽略routingKey）；头：按消息头匹配         |
| 消息可靠性保障   | 生产者确认、消息持久化、消费者确认、死信队列                                    | 生产者确认：确保消息送达broker；持久化：避免宕机丢失；消费者ACK：确保消息处理完再确认；死信队列：处理未消费/过期消息 |
| 高可用方案     | 集群部署、镜像队列、Federation/Shovel                               | 集群：多节点分担负载；镜像队列：队列数据同步到多个节点；Federation/Shovel：跨集群数据同步           |
| 消息挤压与限流   | 消息挤压原因、消费者限流（prefetch_count)、队列扩容                         | 挤压原因：消费速度＜生产速度；限流：设置prefetch_count，空值消费者每次拉取消息数；解决：扩容消费者/优化消费逻辑 |
| 延迟队列实现    | 普通队列TTL+死信队列、延迟交换机                                        | rabbitmq_delayed_message_exchange插件：直接支持延迟发送，无需额外配置             |
| 事务与发布确认   | rabbitmq事务（Tx Select/Tx Commit/Tx Rollback)、发布确认（confirm） | 事务：保证消息原子发送（性能低）；发布确认(confirm模式)：异步确认消息送达                       |
| 消息重复消费处理  | 幂等性设计（唯一消息ID、业务幂等逻辑）                                      | 因网络波动、ack超时等导致消息重复；通过“消息唯一ID去重”“业务逻辑幂等（如订单号防重）”解决               |
| 常见问题排查    | 消息丢失、消息重复、消息挤压、交换机路由失败（Return回调）                          | 消息丢失：未开持久化/ACK/生产者确认；路由失败：交换机与队列未绑定/路由键不匹配（由Return回调接口捕获）       |
| 其他关键考点    | 临时队列、优先级队列、消息TTL                                          | 临时队列：仅当前链接可用，断开自动删除；优先级队列：按消息优先级顺序消费；消息TTL：设置消息过期时间；            |
| 与其他MQ对比   | 与kafka、rocketMQ的差异                                        | 优势：可靠性高、协议完善、路由灵活；劣势：吞吐量低于kafka；适用对可靠性要求高的中低吞吐量场景               |

# JVM：

| 考察方向        | 核心知识点                                                                                 | 简要说明                                                                                                                                       |
|-------------|---------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------|
| JVM内存结构     | 程序计数器、虚拟机栈、本地方法栈、堆、方法区（元空间）、直接内存                                                      | 程序计数器：线程私有，记录指令地址；虚拟机栈/本地方法栈：线程私有，存储栈帧；堆：线程共享，GC核心区域；元空间：替代永久代，存储类元数据；直接内存：堆外内存。                                                           |
| 垃圾回收核心      | GC算法（标记-清除、复制、标记-整理、分代收集）、垃圾回收器（Serial/Parallel/CMS/G1/ZGC)、GC触发条件、STW                | 算法：标记-清除（碎片多）、复制（无碎片、浪费空间）、标记-整理（老年代用）；收集器：Serial（单线程）、Parallel（多线程吞吐量优先）、CMS（并发标记清除，低延迟）、G1（分区回收，兼顾吞吐与延迟）、ZGC（低延迟，毫秒级SWT）；STW:GC时暂停所有用户线程 |
| 内存分配与回收策略   | 对象优先在Eden区分配、对象直接进入老年代、长期存活对象进入老年代、动态对象年龄判断、空间分配担保                                    | Eden区满时触发MinorGC；MinorGC前检查老年代剩余空间是否足够，不足则Full GC                                                                                          |
| 类加载机制       | 类加载流程（加载→验证→准备→解析→初始化）、类加载器（启动类/扩展类/应用类/自定义）、双亲委派机制                                   | 加载：读取类字节码；验证：验字节流是否合规；准备：为静态变量分配内存；解析：符号引用改为直接引用；初始化：执行静态代码块，赋值静态变量；双亲委派：子类加载器先委托付类加载，避免类重复加载（可打破）                                         |
| OOM与泄漏      | 堆OOM、栈溢出、员工间OOM、直接内存OOM、内存泄漏场景                                                        | 堆OOM：对象无法回收；栈溢出：递归过深/栈帧过大；内存泄漏：未释放资源（静态集合、未关闭连接、线程池滥用），最终导致OOM                                                                             |
| JVM参数配置     | 堆大小（-Xms/-Xmx)、元空间（-XX:MaxMetaspaceSize)、GC日志（-XX:+PrintGCDetails)、收集器指定（-XX:useG1GC) |                                                                                                                                            |
| JIT编译（即时编译） | 热点代码、解释执行vs编译执行、JIT编译期（C1/C2）、分层编译                                                    |                                                                                                                                            |
| 逃逸分析与优化     | 逃逸分析、栈上分配、标量替换、锁消除                                                                    |                                                                                                                                            |
| 性能分析与问题排查   | 调优目标（降低GC频率、减少STW时间）、调优工具（jps/jstat/jmap/jhat/Arthas）、调优流程                            | 工具：jps查进程、jsta监控GC，jmap导出堆快照、Arthas在线排查；调优过程：定位问题→分析原因→优化                                                                                  |
| 类加载器延伸      | 双亲委派模型打破场景、线程上下文类加载器、模块化（jdk9+）                                                       | 打破场景：Tomcat(Web应用独立类加载）、SPI机制（如JDBC)；线程上下文类加载器：解决双亲委派无法加载第三方类的问题；模块化：JDK9+引入，按需加载类，减少内存占用                                                  |
| 其他核心考点      | 常量池、对象创建流程、对象存活判定（可达性分析）                                                              | 字符串常量池：jdk7+移至堆中，避免永久代OOM；可达性分析：以GC Roots（如线程栈引用、静态变量）为起点，判断对象是否回收。对象创建：雷加载检查→分配内存→初始化零值→设置对象头→执行狗仔方法                                      |


