# 概要

设计模式分为创造型模式、结构型模式、行为型模式三大类。

# 创造型模式：

`关注对象的创建过程，解耦对象的创建与使用，降低创建逻辑的复杂度。`

- 单例模式：
    - 定义：确保类只有一个实例，提供全局访问点。
    - 示例：双检锁、静态内部类、枚举
    - 应用场景：Spring Bean默认单例、配置管理器、数据库连接池、日志对象
- 工厂方法模式:
    - 定义创建对象的接口，让子类决定实例化哪个类。
    - 示例：产品接口+具体产品+工厂接口+具体工厂
    - 应用场景：JDBC的DriverManager、日志框架、mybatis的SqlSessionFactory
- 抽象工厂模式：
    - 提供创建一系列相关/依赖对象的接口，无需指定具体类。
    - 示例：
    - 应用场景：spring的beanFactory
- 建造者模式：
    - 将复杂对象的构建与表示分离，逐步构建对象。
    - 示例：builder接口+具体builder+ director角色
    - 应用场景：StringBuilder、mybatis的sqlSessionFactoryBuilder
- 原型模式：
    - 通过复制现有实例创建新实例，避免重复初始化。
    - 示例：实现cloneable接口，重写clone()
    - 应用场景：spring原型bean，对象池（复用大对象）

# 结构型模式：

`关注类/对象的组合结构，优化类间关系，提高代码灵活性和复用性。`

- 适配器模式：
    - 定义：将一个类的接口转换成客户希望的另一个接口，使原本由于接口不兼容而不能一起工作的类可以一起工作。
    - 示例：类适配器、对象适配器、接口适配器、InputStreamReader（字节流→字符流）
    - 应用场景：旧系统改造、第三方SDK集成、不同数据格式转换、SpringMVC 的HandlerAdapter
- 装饰器模式：
    - 定义：动态地给对象添加额外的职责，比生成子类更灵活。
    - 示例：装饰器接口+具体装饰器+被装饰对象、Java IO（BufferedReader装饰Reader）
    - 应用场景：Java I/O流、权限扩展、日志增强、Spring 的TransactionAwareCacheDecorator
- 代理模式：
    - 定义：为其他对象提供一种代理，以控制对这个对象的访问。
    - 示例：静态代理、动态代理(JDK/CGLIB)、远程代理、虚拟代理
    - 应用场景：Spring AOP、RPC调用、防火墙代理、权限控制
- 组合模式：
    - 定义：将对象组合成树形结构以表示"部分-整体"的层次结构，使得用户对单个对象和组合对象的使用具有一致性。
    - 示例：抽象组件+叶子节点+容器节点
    - 应用场景：文件系统、组织架构图、菜单系统、XML解析
- 外观模式：
    - 定义：为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，使得这一子系统更加容易使用。
    - 示例：外观类封装多个子系统组件的调用
    - 应用场景：API网关、复杂库的简化接口、微服务统一入口
- 享元模式：
    - 定义：运用共享技术有效地支持大量细粒度对象的复用，减少内存占用。
    - 示例：享元工厂+内部状态+外部状态
    - 应用场景：String常量池、数据库连接池、线程池、棋盘游戏棋子
- 桥接模式：
    - 定义：将抽象部分与实现部分分离，使它们都可以独立变化。
    - 示例：抽象类+扩充抽象类+实现类接口+具体实现类
    - 应用场景：跨平台UI工具包、数据库驱动程序、消息发送方式

# 行为型模式：

`关注对象间的交互与职责分配，解耦通信逻辑，提高代码的可维护性。`

- 策略模式
    - 定义：定义一系列算法，把它们一个个封装起来，并且使它们可以互相替换。策略模式让算法的变化独立于使用算法的客户。
    - 示例：策略接口+具体策略实现类+上下文类
    - 应用场景：支付方式选择、排序算法切换、促销策略选择、路由算法选择
- 观察者模式：
    - 定义：定义对象间一对多的依赖关系，当一个对象状态改变时，所有依赖它的对象都会得到通知并自动更新。
    - 示例：Java内置Observer/Observable、事件监听机制、消息订阅发布
    - 应用场景：GUI事件处理、Spring事件驱动模型、消息中间件
- 模板方法模式：
    - 定义：定义算法骨架，将一些步骤延迟到子类实现，使得子类可以在不改变算法结构的情况下重新定义算法的某些特定步骤。
    - 示例：抽象模板类定义算法流程，具体子类实现可变部分
    - 应用场景：框架设计、Servlet的doGet/doPost、Spring的JdbcTemplate
- 迭代器模式：
    - 定义：提供一种方法顺序访问聚合对象中的各个元素，而又不暴露其内部表示。
    - 示例：Java集合框架中的Iterator、ListIterator
    - 应用场景：各种集合类的遍历操作、统一访问不同数据结构
- 命令模式：
    - 定义：将请求封装成对象，从而使你可以用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。
    - 示例：命令接口+具体命令+调用者+接收者
    - 应用场景：菜单系统、按钮点击事件、事务管理、日志系统
- 责任链模式：
    - 定义：使多个对象都有机会处理请求，从而避免请求发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止。
    - 示例：处理器接口+具体处理器+链式调用
    - 应用场景：异常处理、过滤器链、审批流程、Web请求处理
- 状态模式：
    - 定义：允许对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。
    - 示例：状态接口+具体状态类+上下文环境类
    - 应用场景：工作流引擎、游戏状态管理、订单状态处理
- 中介者模式：
    - 定义：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。
    - 示例：中介者接口+具体中介者+同事类
    - 应用场景：聊天室、MVC架构中的Controller、GUI组件交互
- 解释器模式：
    - 定义：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。
    - 示例：抽象表达式+终结符表达式+非终结符表达式+环境类
    - 应用场景：正则表达式解析、SQL解析器、数学表达式计算
- 备忘录模式：
    - 定义：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可将该对象恢复到原先保存的状态。
    - 示例：备忘录类+原发器类+管理者类
    - 应用场景：文本编辑器撤销功能、游戏存档、浏览器后退功能
