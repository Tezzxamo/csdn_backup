<!-- TOC -->
* [概要](#概要)
* [锁的种类](#锁的种类)
  * [一、按照思想分类：](#一按照思想分类)
    * [1、乐观锁：](#1乐观锁)
    * [2、悲观锁：](#2悲观锁)
  * [二、按照机制分类：](#二按照机制分类)
    * [1、公平锁：](#1公平锁)
    * [2、非公平锁：](#2非公平锁)
    * [3、互斥锁：](#3互斥锁)
    * [4、读写锁：](#4读写锁)
    * [5、自旋锁：](#5自旋锁)
    * [6、偏向锁：](#6偏向锁)
    * [7、轻量级锁：](#7轻量级锁)
    * [8、重量级锁：](#8重量级锁)
    * [9、可重入锁：](#9可重入锁)
    * [10、分段锁：](#10分段锁)
    * [11、分布式锁：](#11分布式锁)
  * [三、按照固定属性分类：](#三按照固定属性分类)
    * [1、按`使用范围`分类：](#1按使用范围分类)
    * [2、按`排他性`分类：](#2按排他性分类)
    * [3、按`公平性`分类：](#3按公平性分类)
    * [4、按`可重入性`分类：](#4按可重入性分类)
    * [5、按`锁状态`分类：](#5按锁状态分类)
    * [6、按`获取方式`分类：](#6按获取方式分类)
    * [7、按`颗粒度`分类：](#7按颗粒度分类)
<!-- TOC -->

# 概要

`锁是并发编程的基础，对锁进行简单描述并分类。`

# 锁的种类

1. 按照**思想**分类：乐观锁、悲观锁
2. 按照**机制**分类：公平锁、非公平锁、互斥锁、共享锁、读写锁、自旋锁、偏向锁、轻量级锁、重量级锁、可重入锁、分段锁、分布式锁
3. 按照**固定属性**分类：使用范围、排他性、公平性、重入性、锁状态、获取方式、颗粒度

## 一、按照思想分类：

`锁的核心设计逻辑，决定对待并发冲突的态度`

### 1、乐观锁：

    思想核心：默认无并发冲突、仅在提交时校验数据的一致性。
    适用场景：读多写少，并发冲突少。
    实现方式(举例)：CAS

### 2、悲观锁：

    思想核心：默认有并发冲突，获取资源时直接上锁，防止其他线程访问。
    适用场景：写多读少，并发冲突多。
    实现方式(举例)：synchronized；ReentrantLock

## 二、按照机制分类：

`锁在具体实现时的调度机制，定义如何锁定资源，处理竞争。`

### 1、公平锁：

- 描述：线程获取锁的顺序严格按照请求时间顺序，FIFO，先到先得，无饥饿现象。
- 实现原理：获取锁前检查阻塞队列，若有等待线程则入队，不直接尝试CAS。
- 适用场景：对顺序性要求高，如任务队列，消息消费。
- 实现方式(举例): ReentrantLock参数设置为true；zookeeper分布式锁;

### 2、非公平锁：

- 描述：不按照请求顺序分配，允许插队，吞吐量更高。
- 适用场景：对顺序性要求不高，追求高并发。
- 实现方式(举例): ReentrantLock参数设置为false；synchronized；redis分布式锁；

### 3、互斥锁：

- 描述：同一时间仅允许一个线程持有，强制串行执行。只有两种状态：锁定、未锁定。
- 适用场景：单资源竞争、写多读少。
- 实现方式(举例): synchronized

### 4、读写锁：

- 描述：支持多个线程同时持有读锁，但是写锁只能独占。有三个状态：读锁(共享锁)、写锁(互斥锁)、未锁定。
- 读写规则：读读并发、读写互斥（读时不允许写，写时不允许读）、写写互斥。
- 适用场景：读操作远多于写操作，如缓存读取。
- 实现方式(举例): ReentrantReadWriteLock

### 5、自旋锁：

- 描述：获取锁失败时循环重试，不切换线程状态。
- 适用场景：锁持有时间短。
- 实现方式(举例): CAS

### 6、偏向锁：

- 描述：多线程环境下实际上只有单线程在获取锁时，只会在第一次获取锁时进行一次CAS，后续再次访问时不需要CAS。
- 适用场景：单线程重复访问同步资源、无竞争或极低竞争的并发场景(当线程B获取锁时，线程A已经释放资源，则继续保持偏向锁)。
- 锁升级：当第一个线程尝试进入synchronized块时，将无锁升级为偏向锁；当有其他线程获取锁时存在竞争，则将偏向锁升级为轻量级锁。
- 实现方式(举例): synchronized

### 7、轻量级锁：

- 描述：当偏向锁升级时，锁升级为轻量级锁，竞争时通过CAS自旋，不阻塞线程，每次获取锁都需要一次CAS，若是获取不成功则进入自旋状态，若是自旋达到阈值还没有获取则升级为重量级锁。
- 适用场景：低竞争并发场景。
- 锁升级：当第一个线程尝试进入synchronized块时，将无锁升级为偏向锁；当有其他线程获取锁时存在竞争，则将偏向锁升级为轻量级锁；当轻量级锁获取锁失败后自旋次数达到阈值，则将轻量级锁升级为重量级锁。
- 实现方式(举例): synchronized

### 8、重量级锁：

- 描述：当轻量级锁升级时，锁升级为重量级锁，放弃自旋，竞争时阻塞线程，是一个悲观锁，依赖操作系统实现线程切换。
- 适用场景：高竞争并发场景。
- 锁升级：当第一个线程尝试进入synchronized块时，将无锁升级为偏向锁；当有其他线程获取锁时存在竞争，则将偏向锁升级为轻量级锁；当轻量级锁获取锁失败后自旋次数达到阈值，则将轻量级锁升级为重量级锁。
- 实现方式(举例): synchronized

### 9、可重入锁：

- 描述：同一个线程可以多次获取同一把锁，避免死锁。
- 适用场景：递归调用、循环调用。
- 实现方式(举例): synchronized；ReentrantLock；

### 10、分段锁：

- 描述：锁的粒度更细，对数据进行分段，对不同段进行互斥。
- 适用场景：高并发且数据具备一定分区特征；读多写少或写操作分散在多个区域；
- 实现方式(举例): java7的ConcurrentHashMap；mysql的行锁、表锁；redis集群槽位分片(分段锁思想延伸)；

### 11、分布式锁：

- 描述：跨进程/集群的全局锁，用于解决分布式系统中共享资源的并发竞争问题。
- 本质：本地锁的分布式扩展，突破“进程内锁定”的限制，实现跨服务器、跨应用的全局互斥。
- 核心目标：保证分布式环境中，同一时间只有一个线程(或进程)操作共享资源。
- 适用场景：分布式任务调度(避免同一任务在多个节点重复执行)；库存扣减；订单创建；缓存更新；分布式资源竞争；
- 实现方式(举例): 分布式锁
    - redis分布式锁:使用Redission框架。(高并发场景)
    - zookeeper分布式锁：严格公平。(公平性要求高)
    - 数据库分布式锁：无额外中间件。(适合并发量不高的场景)

## 三、按照固定属性分类：

`锁本身具备的固定特性，不随使用场景改变。`

### 1、按`使用范围`分类：

- 线程锁：单个进程内多线程间锁。
- 分布式锁：跨多个进程、多个服务、多台机器，在分布式系统中控制多个服务对共享资源的互斥访问的锁。

### 2、按`排他性`分类：

- 互斥锁：同一时刻只允许一个线程持有锁。
- 共享锁(读锁)：多个线程可以同时持有锁进行读操作，但写操作需要排他。

### 3、按`公平性`分类：

- 公平锁：线程获取锁的顺序严格按照请求时间顺序，FIFO，先到先得，无饥饿现象。
- 非公平锁：不按照请求顺序分配，允许插队，吞吐量更高。

### 4、按`可重入性`分类：

- 可重入锁：不按照请求顺序分配，允许插队，吞吐量更高。
- 不可重入锁：同一个线程不能重复获取已经持有的锁，否则会导致死锁。

### 5、按`锁状态`分类：

- 偏向锁：多线程环境下实际上只有单线程在获取锁。
- 轻量级锁：线程间轻微竞争。
- 重量级锁：竞争激烈时使用，依赖操作系统 Mutex，线程会被挂起。

### 6、按`获取方式`分类：

- 隐式锁：由语言或运行时环境自动管理，开发者无需手动加锁/解锁。
- 显式锁：需要开发者手动调用加锁和解锁方法。

### 7、按`颗粒度`分类：

- 粗粒度锁：
    - 描述：锁定整个共享资源(或资源的大颗粒单元)，同一时间所有线程对该资源的操作都需要竞争同一把锁。
    - 核心特点：锁粒度大，竞争激烈，但锁管理简单(仅需要维护一把锁)，无资源拆分和定位开销。
    - 实例：mysql表锁；
- 细粒度锁：
    - 描述：锁定资源的局部片段(而非整个资源)，不同线程可同时操作不同片段，仅竞争目标片段的锁。
    - 核心特点：锁粒度小，竞争强度低，并发效率高，但需要拆分资源、维护多把锁，存在资源定位和锁管理开销。
    - 实例：mysql行锁、列锁；分段锁；


    