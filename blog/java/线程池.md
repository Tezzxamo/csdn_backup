# 概要

线程池是管理线程生命周期的资源池，核心思想是预先创建一批线程复用，避免频繁创建/销毁线程的系统开销，同时可以统一控制并发数、管理任务队列、处理任务拒绝策略，是高并发场景下的核心基础组件。

# 一、线程池核心参数：

## 1、核心线程数：corePoolSize

- 线程池的常驻线程数，即使空闲也不会销毁（除非设置`allowCoreThreadTimeOut(true)`）
- 任务提交时，若当前线程数 < `corePoolSize`，会优先创建`核心线程`执行任务。

## 2、最大线程数：maximumPoolSize

- 线程池允许创建的最大线程数，`maximumPoolSize` = 核心线程数 + 非核心线程数
- 当核心线程满载，且任务队列已满时，线程池会创建非核心线程，直到达到该上限，否则触发拒绝策略。

## 3、空闲存活时间：keepAliveTime

- 仅针对非核心线程，当非核心线程空闲超过`keepAliveTime`，线程池会销毁该线程
- 若开启`allowCoreThreadTimeOut(true)`，则`keepAliveTime`也会作为核心线程的存活时间

## 4、时间单位：TimeUnit

- 时间单位，用于设置`keepAliveTime`

## 5、任务队列：workQueue

- 核心线程满后，新任务将会进入任务队列等待执行。
- 队列类型决定了线程池的调度行为：
    - 有界队列ArrayBlockingQueue：有界，FIFO,可防止OOM。
    - 无界队列LinkedBlockingQueue：无界，默认最大容量Integer.MAX_VALUE，易导致任务堆积 → OOM。
    - 无缓冲的特殊阻塞队列SynchronousQueue：无存储能力，任务直接传递给线程（无线程则创建），不缓存任务。
    - 优先级队列PriorityBlockingQueue：优先级队列，任务按照优先级执行（需要实现Comparable接口）。

## 6、线程工厂：ThreadFactory

- 用于创建线程，可以自定义线程名称、优先级、是否为守护线程、异常处理器；
- 默认使用`Executors.defaultThreadFactory()`创建线程，线程名称：`pool-${poolName}-thread-${threadNumber}`

## 7、拒绝策略：RejectedExecutionHandler

- 当线程数达到`maximumPoolSize`，且任务队列已满时，线程池会触发拒绝策略。
- JDK默认提供了4种拒绝策略，也可以自定义（实现`RejectedExecutionHandler`接口）:
    - AbortPolicy：默认策略，直接抛出异常 `java.util.concurrent.RejectedExecutionException`，中断任务提交。
    - CallerRunsPolicy： 由提交任务的线程执行该任务，降低并发压力(优雅降级)。
    - DiscardPolicy：静默丢弃任务，不会抛出异常。
    - DiscardOldestPolicy：丢弃队列中最老的任务，将新任务加入到任务队列中。

# 二、线程池工作原理（核心流程）：

- 严格遵循 "核心流程 → 任务队列 → 非核心线程 → 拒绝策略" 的顺序。

- 补充，线程池状态：
    - RUNNING: 正常执行并接收任务。
    - SHUTDOWN: 不接收新任务，但会处理队列中的任务。
    - STOP: 不接收新任务，不处理队列中的任务，中断运行中的任务。
    - TIDYING: 所有任务执行完毕，线程数为0，等待执行`terminated()`方法。
    - TERMINATED: 线程池已销毁。

# 三、JDK预定义线程池：

## 1、FixedThreadPool：

- core = max = N , 无界队列

## 2、SingleThreadExecutor:

- core = max = 1 , 无界队列

## 3、CachedThreadPool：

- core = 0, max = Integer.MAX_VALUE, SynchronousQueue , 存活时间 60s

## 4、ScheduledThreadPool:

- core = N , max = Integer.MAX_VALUE, DelayedWorkQueue延时任务队列（能够按照任务的延迟时间升序排列任务，确保即将到期的任务先执行）

## 5、WorkStealingPool（JDK8+）：

- 基于ForkJoinPool实现，线程数由CPU核数决定，任务窃取机制（每个工作线程维护一个本地任务队列，当本地任务队列为空时，会从其他线程的任务队列尾部窃取任务，从而减少线程竞争并平衡负载。）




















